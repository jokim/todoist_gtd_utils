#!/bin/env python
# -*- encoding: utf-8 -*-

""" Create an item (task) in Todoist from piping mails from mutt.

Meant to be called from mutt by piping the full mail to the script. Example of
macro config for mutt::

    macro index,pager GG "<pipe-entry>less > \
        /tmp/mutt-$USER-mail-todoist.tmp<enter>\
        <shell-escape>todoist_add_mail_item \
            /tmp/mutt-$USER-mail-todoist.tmp<enter>"

You will then be asked for content, project, labels and date.

TODOs:

- Add unittesting!
- Add bash coloring
- Prettify presentation of mail headers on multiple, indented lines
- Support signals, like CTRL+C and CTRL+D when getting input

"""

from __future__ import unicode_literals
from __future__ import print_function

import sys
import signal
from threading import Thread
import re
import argparse
import email
import email.header
from todoist.api import SyncError
from todoist_gtd_utils import utils
from todoist_gtd_utils import TodoistGTD


def signal_handler(signal, frame):
    """Prettier abort"""
    print("\nQuit, not commit")
    sys.exit(0)


def do_commit(api):
    """Make sure a commit with Todoist is commited."""
    try:
        api.commit(raise_on_error=True)
    except SyncError:
        # Sometimes, the sync fails due to "Invalid temporary id
        # (INVALID_TEMPID)". Haven't dug out the cause, but a retry most often
        # fix the issue:
        api.commit(raise_on_error=True)
    return True


def parse_content(api, content):
    """Get labels, projects and date out of a content string.

    NOT as advanced as Todoist own parser. Does for instance not support
    white space in labels and projects.

    """
    # Find project (#projectname)
    project = "Inbox"
    r = re.search('#(\w+)', content)
    if r:
        p = r.groups()[0]
        try:
            api.get_projects_by_name(p)
        except Exception:
            pass
        else:
            project = p
            content = content.replace('#' + p, '')

    # Find labels (@labelname)
    labelnames = set(l['name'].lower() for l in api.labels.all())
    labels = set(l for l in re.findall('\@(\w+)', content)
                 if l.lower() in labelnames)
    for l in labels:
        content = content.replace('@' + l, '')

    content, date = parse_date(content)

    # Remove superfluous spaces
    content = re.sub('  +', ' ', content).strip()
    return content, project, date, labels

dateformats = ('(mon|tues|wednes|thurs|fri|satur|sun)day', 'tomorrow', 'today',
               'next month', 'next year', '[0-3]?[0-9]\. [a-z]{3,6}( \d{4})?',
               '\d+ (day|week|month|year)s?',
               )
timeformats = ('[0-1][0-9]:[0-5][0-9]',)


def parse_date(content):
    """Return first date format found, and remove from content"""
    for d in dateformats:
        m = re.search('({}( {})?)'.format(d, timeformats), content)
        if m:
            return content.replace(m.groups()[0], ''), m.groups()[0]
    return content, None


def gather_input(content, api, args):
    """Ask user for info about the new item."""
    content, project, date, labels = parse_content(api, content)

    print()
    # TODO: colorize invalid project and label names (# and @), to highlight
    # what looks like typos
    print(content)
    print()

    projects = set(unicode(p['name']) for p in api.projects.all())
    project = utils.ask_choice('Project', choices=projects, default=project,
                               category="project")
    all_labels = set(unicode(l['name']).lower() for l in api.labels.all())
    labels = utils.ask_multichoice('Labels', choices=all_labels,
                                   default=labels, category="labels")
    date = utils.ask_choice('Date', choices=dateformats, default=date,
                            category="date", regex_choices=True)
    return content, project, date, labels


class SimpleMail(object):
    """Mail data needed for this script, in Unicode and prettified."""

    def __init__(self, mailfile):
        self.mail = email.message_from_file(mailfile)

    def get_header(self, key):
        """Return a mail's header, unicodified."""
        raw = self.mail.get(key)
        if not raw:
            return raw
        return utils.trim_whitespace(
            ' '.join(unicode(t[0], t[1] or 'latin1') for t in
                     email.header.decode_header(raw)))

    def get_body(self):
        # TODO: support encoding
        if self.mail.is_multipart():
            # TODO: Filter html etc
            return '\n'.join(p.get_payload(decode=True) for p in
                             self.mail.get_payload() if p)
        else:
            return unicode(self.mail.get_payload(decode=True),
                           self.mail.get_content_charset())

    def get_presentation(self, *args, **kwargs):
        """Return a presentable formatted mail.

        Each *args argument could be prefixed with:

        * = The header and its value should be marked with **bold**
        _ = The header should be ignored if no value

        """
        body = kwargs.get('body', True)
        lines = []
        for key in args:
            bold = optional = False
            if key.startswith('*'):
                key = key[1:]
                bold = True
            if key.startswith('_'):
                key = key[1:]
                optional = True

            value = mail.get_header(key)
            if optional and not value:
                continue
            if bold:
                lines.append('**{}: {}**'.format(key, value))
            else:
                lines.append('{}: {}'.format(key, value))
        if body:
            lines.append('')
            lines.append(mail.get_body())
        return '\n'.join(lines)


def create_api(args):
    """Setup the Todoist API.

    To be called in a thread, which is why it adds the api through the `global`
    syntax.

    """
    global api
    api = TodoistGTD(configfiles=args.configfile, token=args.token)


if __name__ == '__main__':
    signal.signal(signal.SIGINT, signal_handler)
    p = utils.get_argparser(usage="%(prog)s [options] MAILFILE",
                            description=__doc__)
    p.add_argument('mail', metavar="MAILFILE", type=argparse.FileType('r'),
                   help="Mail to store as note. Defaults to piped input, e.g. "
                   "from mutt",
                   )
    args = p.parse_args()
    mail = SimpleMail(args.mail)

    print()
    print(mail.get_presentation('Date', 'From', '_Sender', 'To', 'Cc',
                                'Subject', body=False))
    print()

    t = Thread(target=create_api, name='create_api', kwargs={'args': args})
    t.start()
    content = unicode(raw_input("New task: "), 'utf-8')
    t.join()
    # Authenticate
    if not api.is_authenticated():
        utils.login_dialog(api)

    api.sync()

    while True:
        content, project, date, labels = gather_input(content, api, args)

        # Add emoji for mark that item came by email:
        content += ' :email:'
        i = api.items.add(content, priority=1, indent=1,
                          project_id=api.get_projects_by_name(project)['id'],
                          date_string=date, labels=api.get_label_id(labels))
        print("\nNew item:\n{}\n".format(i))
        if utils.ask_confirmation("Okay to create?", args):
            do_commit(api)
            api.notes.add(i['id'], mail.get_presentation('Date', '*From', 'To',
                                                         'Message-Id',
                                                         '_Reply-To',
                                                         '*Subject',
                                                         '_Sender'))
            do_commit(api)
            print("\nItem created")
            break
        else:
            print("\nGoing all over again...\n")
