#!/bin/env python
# -*- encoding: utf-8 -*-

"""Clean up GTD data in Todoist, where needed.

For now supports:

- Archive labels for items in Someday/Maybe. This is so they aren't in the way
  when they are postponed.

- TODO: Unarchive labels for items moved back to active projects.

"""

from __future__ import print_function
from __future__ import unicode_literals

from todoist_gtd_utils import userinput
from todoist_gtd_utils import utils
from todoist_gtd_utils import TodoistGTD


def remove_labels_in_someday(api, args):
    """Archive labels from items in Someday/Maybe.

    Remove label, and add it as a comment, so that it's possible to restore.

    """
    somedaymaybe_project_name = 'Someday Maybe'
    print("Remove labels in {}…".format(somedaymaybe_project_name))
    ignore_labels = api.config.get_commalist('cleanup', 'ignore-labels')
    ignore_l_ids = set(map(api.get_label_id, ignore_labels))
    print("Ignore labels: {}".format(', '.join(ignore_labels)))

    proj = api.get_projects_by_name(somedaymaybe_project_name)
    child_pr = list(api.get_child_projects(proj))
    print("Processing {} projects…".format(len(child_pr)))
    child_pr_ids = set(p['id'] for p in child_pr)
    items = api.items.all(lambda x: x['project_id'] in child_pr_ids)
    print("Processing {} items…".format(len(items)))

    def add_labels(content, labels):
        adds = set()
        for l in labels:
            l = '__' + l
            if l not in content:
                adds.add(l)
        return content + ' '.join(adds)

    for i in items:
        labels_to_remove = set(i['labels']) - ignore_l_ids
        if not labels_to_remove:
            continue
        print("\n{}".format(i.get_presentation()))
        labelnames = api.get_label_name(labels_to_remove)
        if userinput.ask_confirmation(u"Ok to remove labels: {}?".format(
                ', '.join(labelnames)), args):
            # TODO: add support for editing the labels and not just y/n?
            remaining_l = set(i['labels']) - labels_to_remove
            for l in labels_to_remove:
                api.notes.add(i['id'], "gtd_utils:removed_label:{}:{}"
                              .format(l, api.get_label_name(l)))
            i.update(labels=list(remaining_l), content=add_labels(i['content'],
                                                                  labelnames))
            api.force_commit()
    api.force_commit()
    api.sync()
    print("Done removing labels in {}".format(somedaymaybe_project_name))


def restore_labels_in_projects(api):
    """Restore archived labels from reactivated items"""
    # TODO: Add target projects to config!
    target_projects = ['Personal', 'Work']
    print("Restore labels from {}…".format(', '.join(target_projects)))
    item_ids = set()
    for p in target_projects:
        proj = api.get_projects_by_name(p)
        child_pr = set(p['id'] for p in api.get_child_projects(proj))
        child_pr.add(proj['id'])
        print("Processing {} projects from {}…".format(len(child_pr), p))
        print(api.get_project_name(child_pr))
        items = api.items.all(lambda x: x['project_id'] in child_pr)
        print("Processing {} items from {}…".format(len(items), p))
        item_ids.update(i['id'] for i in items)

    def get_match(comment):
        if (comment.startswith('gtd_utils:removed_l') or
                comment.startswith('gtd_clean:removed_l')):
            return True
        return False

    def remove_labels(content, labels):
        for l in labels:
            content = content.replace('__' + l, '')
        return content.strip()

    notes = api.notes.all(lambda x:
                          x['item_id'] in item_ids and
                          get_match(x['content']))
    print("Found {} removed labels to restore".format(len(notes)))

    targets = {}
    for n in notes:
        targets.setdefault(n['item_id'], []).append(n)
    for i, notes in targets.iteritems():
        item = api.items.get_by_id(i)
        labels = []
        for n in notes:
            data = n['content'].split(':')
            l = data[2]
            if l in item['labels']:
                continue
            if not api.labels.get(l):
                print(item)
                print("WARN: Label {} doesn't exist. Data: {}".format(l, data))
                continue
            labels.append(l)
        print("Restore labels for {}: {}".format(
            utils.trim_too_long(item['content']),
            ', '.join(api.get_label_name(labels))))

        item.update(labels=item['labels'] + labels,
                    content=remove_labels(item['content'],
                                          api.get_label_name(labels)))
        api.force_commit()
        # TODO: Verify if labels have been updated first!
        for n in notes:
            n.delete()
        api.force_commit()


if __name__ == '__main__':
    p = userinput.get_argparser(
            description="Clean up in Todoist, for GTD setup")
    args = p.parse_args()
    api = TodoistGTD(configfiles=args.configfile, token=args.token)
    if not api.is_authenticated():
        userinput.login_dialog(api)
    print("Syncing with Todoist…")
    api.sync()

    remove_labels_in_someday(api, args)
    restore_labels_in_projects(api)
